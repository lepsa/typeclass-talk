<!DOCTYPE html>
<html>
  <head>
    <title>Title</title>
    <meta charset="utf-8">
    <style>
      @import url(YanoneKaffeesatz.css);
      @import url(DroidSerif.css);
      @import url(UbuntuMono.css);

      body { font-family: 'Droid Serif'; }
      h1, h2, h3 {
        font-family: 'Yanone Kaffeesatz';
        font-weight: normal;
      }
      .remark-code, .remark-inline-code { font-family: 'Ubuntu Mono'; }
      /* Two-column layout */
      .left-column {
        color: #777;
        width: 25%;
        height: 92%;
        float: left;
      }
      .left-column h2:last-of-type, .left-column h3:last-child {
          color: #000;
        }
      .right-column {
        width: 70%;
        float: right;
        padding-top: 1em;
      }
    </style>
  </head>
  <body>
    <textarea id="source">

class: center, middle

# Intro to Typeclasses
### From S to F

---

.left-column[
# In this talk
]
.right-column[
An overview of what typeclasses are and why you should care about them.
]

---

.left-column[
# In this talk
]
.right-column[
An overview of what typeclasses are and why you should care about them.

A whirl-wind tour of the following typeclasses
- Semigroup
- Monoid
- Functor
- Foldable
]

---

# Followup
- Applicative
- Alternative
- Monad
- Traversable

---

class: center, middle
# Haskell Typeclasses

---

.left-column[
  # Typeclass
]
.right-column[
Allow you define behavours with (hopefully) a set of well-reasoned laws that instances must follow.
]
---

.left-column[
  # Typeclass
]
.right-column[
Allow you define behavours with (hopefully) a set of well-reasoned laws that instances must follow.

A bit like interfaces in C# and Java, or implicits and traits in Scala, but even better.
]

---

.left-column[
  # Typeclass
]
.right-column[
Allow you define behavours with (hopefully) a set of well-reasoned laws that instances must follow.

A bit like interfaces in C# and Java, or implicits and traits in Scala, but even better.

You can define typeclasses on types you didn't write and vice-versa. Try doing that in Java!
]

---

.left-column[
 # Typeclass
 ## Examples
]
.right-column[
```haskell
class Foo t where
  foo :: a -> b
```
]

---

.left-column[
 # Typeclass
 ## Examples
]
.right-column[
```haskell
class Foo t where
  foo :: a -> b

instance Foo Int where
  foo a b = a + b
```
]

---

.left-column[
 # Typeclass
 ## Examples
]
.right-column[
```haskell
class Foo t where
  foo :: a -> b

instance Foo Int where
  foo a b = a + b

myFoo :: Foo f => f -> f -> f -> f
myFoo a b c = foo a $ foo b c 
```
]

---

.left-column[
 # Typeclass
 ## Examples
]
.right-column[
```haskell
class Foo t where
  foo :: a -> b

instance Foo Int where
  foo a b = a + b

myFoo :: Foo f => f -> f -> f -> f
myFoo a b c = foo a $ foo b c 
```

Compare too similar mechanisms in Java and Scala(z).

```java
public interface Appendable {
  Appendable append(char c);
}
public class Foo impliments Appendable { ... }
```
```scala
trait Semigroup[S] {
  append(s1: S, s2: => S): S
}
implicit def FooSemigroup: Semigroup[Foo] =
  semigroup((a, b) => ???)
```
]

---

.left-column[
 # Typeclass
 ## Examples
 ## Features
]
.right-column[
You can restrict what types can have instances with typeclass
restrictions and kinds.

For extra kicks you can even define function implementions in typeclasses.

```haskell
-- t must be of kind * -> *
-- container types often have this kind.
class Bar t where
  foo :: t a -> (a -> t b) -> t b
  bar :: t a -> t b -> t b
  bar a b = foo a $ \_ -> b

instance Bar Maybe where
    foo (Just a) f = Just $ f a
    foo Nothing _  = Nothing
```
]

---

.left-column[
 # Typeclass
 ## Examples
 ## Features
 ## Further Reading
]
.right-column[
##George Wilson's talk at Compose Conf 2017.

###Type Class: The Ultimate Ad Hoc

**Talk** youtube.com/watch?v=2EdQFCP5mZ8

**Slides** github.com/qfpl/typeclass-the-ultimate-ad-hoc/blob/master/slides.pdf
]

---

class: center, middle
### Now that I have (briefly) covered what a typeclass is, let's look at some common cases and what they can be used for.

---

.left-column[
# Semigroup
]
.right-column[
Semigroup is about the simplest typeclass that you are going to be using on a daily basis.
]

---

.left-column[
# Semigroup
]
.right-column[
Semigroup is about the simplest typeclass that you are going to be using on a daily basis.

What is a semigroup?
 - A set of values, which we call a type.
 - A binary operation on that type.
]

---

.left-column[
# Semigroup
]
.right-column[
Semigroup is about the simplest typeclass that you are going to be using on a daily basis.

What is a semigroup?
 - A set of values, which we call a type.
 - A binary operation on that type.

```haskell
class Semigroup a where
  (<>) :: a -> a -> a
```
]

---

.left-column[
# Semigroup
## Laws
]
.right-column[
The haskell class definition of a semigroup is all well and good.
But it doesn't capture the most important part of the typeclass.
]

---

.left-column[
# Semigroup
## Laws
]
.right-column[
The haskell class definition of a semigroup is all well and good.
But it doesn't capture the most important part of the typeclass.

Because with that definition I can do something like this
```haskell
instance Semigroup Integer where
  (<>) :: Integer -> Integer -> Integer
  -- Calculate the quotiant of a and b
  (<>) a b = quot a b
```
]

---

.left-column[
# Semigroup
## Laws
]
.right-column[
The haskell class definition of a semigroup is all well and good.
But it doesn't capture the most important part of the typeclass.

Because with that definition I can do something like this
```haskell
instance Semigroup Integer where
  (<>) :: Integer -> Integer -> Integer
  -- Calculate the quotiant of a and b
  (<>) a b = quot a b
```

And that will compile, but there is an error lying in wait to catch us out.
]

---

.left-column[
# Semigroup
## Laws
]
.right-column[
What happens if I run this snippet?
```haskell
(2 <> 3) <> 4
```
]

---

.left-column[
# Semigroup
## Laws
]
.right-column[
What happens if I run this snippet?
```haskell
(2 <> 3) <> 4  ==  0 <> 4  ==  0
```
]

---

.left-column[
# Semigroup
## Laws
]
.right-column[
What happens if I run this snippet?
```haskell
(2 <> 3) <> 4  ==  0 <> 4  ==  0
```

What about this one?
```haskell
2 <> (3 <> 4)
```
]

---

.left-column[
# Semigroup
## Laws
]
.right-column[
What happens if I run this snippet?
```haskell
(2 <> 3) <> 4  ==  0 <> 4  ==  0
```

What about this one?
```haskell
2 <> (3 <> 4)  ==  2 <> 0  ==  error "divide by zero"
```
]

---

.left-column[
# Semigroup
## Laws
]
.right-column[
What happens if I run this snippet?
```haskell
(2 <> 3) <> 4  ==  0 <> 4  ==  0
```

What about this one?
```haskell
2 <> (3 <> 4)  ==  2 <> 0  ==  error "divide by zero"
```

So the one law that a semigroup must follow is the the function must be associative.
```
a <> (b <> c)  ==  (a <> b) <> c  ==  a <> b <> c
```
]

---

.left-column[
# Semigroup
## Laws
]
.right-column[
Sadly Haskell doesn't have a built in way of enforcing these laws.

That doesn't mean we have to give up all hope. We can write tests that check
that the properties of the typeclass hold for arbitary given values.

This usually goes by the name 'property testing'.

Other languages take this further and make you prove that your code is
correct.
- Coq
- Idris
]

---

.left-column[
# Semigroup
## Laws
## Examples
]
.right-column[
String and list concatenation.

Many collection types will have semigroup instances.
  - Either
  - Maybe
  - Map

Addition and multiplication over Integers. 

Logical OR and AND over Booleans

Getting the first or last value
]

---
 
.left-column[
# Semigroup
## Laws
## Examples
]
.right-column[
Because semigroups are assocative, we can use them in all sorts of
places and know that we are going to get the same answer back.

If I have some lists of data that I wanted to join together, I could send
subsets of my data out to computers to concatenate, and collect their answers.
So long as I keep the order of the responses, it doesn't matter in what order
I combine the results in.

```haskell
l   = [ [1, 2, 3]
      , [4, 5, 6]
      , [7, 8, 9]
      , [10, 11, 12] 
      ]

l1  = [ [1, 2, 3]
      , [4, 5, 6]
      ]
l1' = [1, 2, 3, 4, 5, 6]

l2  = [ [7, 8, 9]
      , [10, 11, 12]
      ]
l2' = [7, 8, 9, 10, 11, 12]

l' = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]
```
]

---

.left-column[
# Monoid
]
.right-column[
Monoids are semigroups that have a value that encodes emptiness or nothingness.
]

---

.left-column[
# Monoid
]
.right-column[
Monoids are semigroups that have a value that encodes emptiness or nothingness.

```haskell
class Semigroup a => Monoid a where
  mappend :: a -> a -> a
  mappend = (<>)
  mempty :: a
```
]

---

.left-column[
# Monoid
## Laws
]
.right-column[
Mathematically, all Monoids are semigroups and can be used where ever a
semigroup is expected. This means they follow the same laws as semigroups.
]

---

.left-column[
# Monoid
## Laws
]
.right-column[
Mathematically, all Monoids are semigroups and can be used where ever a
semigroup is expected. This means they follow the same laws as semigroups.

Sadly this is not the case in haskell today, as of GHC 8.2.1 semigroup uses the
Monoid version of `<>` (called `mappend`) by default, and is not a superclass of Monoid.
(But let's pretend that they are)
]

---

.left-column[
  # Monoid
  ## Laws
]
.right-column[
Since monoids are semigroups, their append / concat function must be associative.
But they also have this `mempty` value that can be used, so what laws does it follow?
]

---

.left-column[
  # Monoid
  ## Laws
]
.right-column[
Since monoids are semigroups, their append / concat function must be associative.
But they also have this `mempty` value that can be used, so what laws does it follow?

```haskell
mempty <> a  ==  a <> mempty  ==  a
```
So the function must, in addition to being associative, have a commutative
identity element, which we call `mempty`.
]

---

.left-column[
  # Monoid
  ## Laws
  ## Examples
]
.right-column[
List forms a monoid with the empty list as its mempty values.
```haskell
[] <> [1] <> [] <> [2, 3]  ==  [1, 2, 3]
```

`""` is the mempty for string.
```haskell
"" <> "A" <> "" <> "BC"  ==  "ABC"
```

Sum uses 0, and Product uses 1.
```haskell
Sum 0 <> Sum 1 <> Sum 2 <> Sum 0  ==  Sum 3

Product 1 <> Product 2 <> Product 3 <> Product 1
  ==  Product 6
```

]

---

.left-column[
  # Monoid
  ## Laws
  ## Examples
]
.right-column[
  So what use is an empty element?
]

---

.left-column[
  # Monoid
  ## Laws
  ## Examples
]
.right-column[
So what use is an empty element?

Monoids are an excellent data structure to use when your computation has some
  connotation of nothingness, or you need a base value that you can build up from.

If I was trying to give you the result of a computation that might fail, I would probably use `Maybe`.

Computations that return 0 or more results, such as database queries, often
return data in lists.

Both of these types are able to collect their results, while ignoring invalid or
missing data.
]

---

.left-column[
  # Monoid
  ## Laws
  ## Examples
  ## Non-Example
]
.right-column[
**NonEmpty** the non-empty list.
]

---

.left-column[
  # Monoid
  ## Laws
  ## Examples
  ## Non-Example
]
.right-column[
**NonEmpty** the non-empty list.

As its name might suggest, doesn't encode an empty value, as it will always
have some value by definition.
```haskell
data NonEmpty a = a :| [a]
```
]

---

.left-column[
  # Monoid
  ## Laws
  ## Examples
  ## Non-Example
]
.right-column[
**NonEmpty** the non-empty list.

As its name might suggest, doesn't encode an empty value, as it will always
have some value by definition.
```haskell
data NonEmpty a = a :| [a]
```

`NonEmpty` can be a Semigroup, but it cannot be a Monoid.

```haskell
instance Semigroup (NonEmpty a) where
  (a :| as) <> (b :| bs) = a :| (as <> (b : bs))

instance Monoid (NonEmpty a) where
  mempty = ???
```

The stronger the typeclass is, the more you can do with it, but your available instances begin to dwindle.
]

---

# Foldable
Foldable types offer functions that allow you to run a function over the values, collecting the results.
The two basic folds that all others are built from are foldl and foldr.
foldl can be thought of as summation or being a bit like a for-loop. foldr tends
to be better thought of as being a type constructor replacing function, but both
work for either case.

class Foldable t where
  foldl :: (a -> b -> a) -> a -> t b -> a
  foldr :: (a -> b -> b) -> b -> t a -> b
  -- Some others
  foldMap :: Monoid m => (a -> m) -> t a -> m
-- TODO, words and more words.



# Functor
Functors are an interesting and fundemental part of haskell programming.
They allow you to apply a function over values that have some context.

For example, how would you apply a funtion to every item in a list?
What about to an optional value?
Trees of values?
What about an IO action?

For the above actions you would probably end up with a function with a type of
(a -> b) -> [] a    -> [] b
(a -> b) -> Maybe a -> Maybe b
(a -> b) -> Tree a  -> Tree b
(a -> b) -> IO a    -> IO b

These all look very similar, all that we are doing is changing the data type holding our values.

So, how do we abstract over datatypes? If you thought typeclasses then congrats! You have been paying attention.

This is Functor
```
class Functor f where
  fmap :: (a -> b) -> f a -> f b
```

And this is what a functor instance looks like.
```
class Functor [] where
  fmap _ []     = []
  fmap f (x:xs) = f x : fmap f xs

instance Functor (Either a) where
    fmap _ (Left x)  = Left x
    fmap f (Right y) = Right (f y)

-- Bonus for those who know Monad.
instance Functor IO where
  fmap f m = m >>= pure . f
```

Like all good typeclasses, Functor must have some laws that we can use.
fmap id == id
fmap (f . g) == fmap f . fmap g

So, what do these laws mean in practice?
Well, if I run the identity function (\x -> x) over the elements of something,
I should get the same values back.
And if I run one function over the structure, then another it should be the
same as doing both at the same time per element. This is basically the function 
composition law, but now we are applying it to values in a context.


# So now that I have these fancy classes, what benefit do they give me?
Abstracting over types for less mental load and easier refactoring.

For example, suppose that I had a function that took a list of numbers, did something
to each value, and the summed everything up.

myFancyCounter :: [Int] -> (Int -> Int) -> Int
myFancyCounter l f = sumValues $ applyFunction l f

applyFunction :: [Int] -> (Int -> Int) -> [Int]
applyFunction []     _ = []
applyFunction (x:xs) f = f x : applyFunction xs f

sumValues :: [Int] -> Int
sumValues []     = 0
sumValues (x:xs) = x + sumValues xs

app :: [Int] -> Int
app l = myFancyCounter l (+ 1)

And it works well, because I wrote it. But when you feed it really big lists it can take a while to run.
You talk to your friend and they say that haskell lists are actually linked
lists and those are slow. You should use Vector instead, which is more like an
array.
So you begin the task of changing all those list annotations over to Vector, changing how you loop over the values.

If this sounds slow, boring, and error prone you would be correct.

In this case we can easily remove applyFunction, and replace it with a functor!

myFancyCounter :: Functor f => f Int -> (Int -> Int) -> Int
myFancyCounter v f = sumValues $ fmap f v

sumValues :: Vector Int -> Int
sumValues v = foldr (+) 0 v

app :: Vector Int -> Int
app v = myFancyCounter v (+ 1)

But what if our values get too big for Int? So we move to Integer. But what if we no longer want to sum the values but get the product instead?
Now we need to remember if we used any special values anywhere and change those.

If we change out the Integer type to be a Monoid we can capture all those requirements in one nice place.
myFancyCounter :: (Monoid m, Functor f) => f m -> (m -> m) -> m
myFancyCounter v f = sumValues $ fmap f v

sumValues :: Monoid m => Vector m -> m
sumValues v = foldr (<>) mempty v

app :: Vector Sum -> Sum
app v = myFancyCounter (+ 1) v


There is still that lingering Vector in sumValues. Since we are already using foldr we can easily change it to work on any Foldable type
myFancyCounter :: (Monoid m, Foldable f, Functor f) => f m -> (m -> m) -> m
myFancyCounter v f = sumValues $ fmap f v

sumValues :: (Foldable f, Monoid m) => f m -> m
sumValues v = foldr (<>) mempty v

app :: Vector Sum -> Sum
app v = myFancyCounter (+ 1) v

Now if we want to change the data type that our app uses, it is all in one place!

We can simplify this even further using some more functions from Foldable

myFancyCounter :: (Monoid m, Foldable f) => f m -> (m -> m) -> m
myFancyCounter v f = foldMap f v

And that is the power of Typeclasses in practice.

    </textarea>
    <script src="remark-latest.min.js">
    </script>
    <script>
      var slideshow = remark.create();
    </script>
  </body>
</html>
